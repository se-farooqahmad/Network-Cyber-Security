from typing import Union, Tuple
import sys
sys.path.append(r'D:\LUMS\Semester 1\CV\download material\CV Assignments\files')
from crypto.primes import PrimeGenerator

class RSA:

    def __init__(self, prime_bit_length : int, seed: Union[int, None] = None):
        """
        Initialize the RSA object with a specified bit length and an optional seed for random number generation.
        :param bit_length: The bit length for the prime numbers to be generated.
        :param seed: An optional seed for the random number generator.
        """

        self.bit_length = prime_bit_length
        self.seed = seed
        self.prime_gen = PrimeGenerator(bits=prime_bit_length, seed=seed)
        self.p = None
        self.q = None
        self.n = None
        self.e = 0x10001     # can be hardcoded to be this value (65537)
        self.d = None

    def set_primes(self, p: int, q: int):
        
        """
        Set the prime numbers p and q, instead of using the ones generated by the PrimeGenerator.
        :param p: The first prime number.
        :param q: The second prime number.
        """
        self.p = p
        self.q = q

    def generate_primes(self):
        
        """
        Generate two distinct prime numbers p and q.
        """
        self.p = self.prime_gen.findPrime()
        self.q = self.prime_gen.findPrime()
        while self.p == self.q:
            self.q = self.prime_gen.findPrime()

    def generate_public_key(self) -> Tuple[int, int]:
        """
        Generate the public key (n, e).
        :return: A tuple containing n and e.
        """
        if self.p is None or self.q is None:
            raise ValueError("Primes p and q must be set before generating the public key.")
        
        self.n = self.p * self.q
        return (self.n, self.e)
        # raise NotImplementedError("Public key generation is not implemented.")

    def generate_private_key(self) -> int:
        """
        Generate the private key d, and saves it interally.
        :return: The private key d.
        """
        # raise NotImplementedError("Private key generation is not implemented.")
        if self.p is None or self.q is None:
            raise ValueError("Primes p and q must be set before generating the private key.")
        
        phi = (self.p - 1) * (self.q - 1)
        self.d = pow(self.e, -1, phi)
        return self.d
    
    def _encode_message(self, message: str) -> int:
        """
        Encode the message into an integer.
        :param message: The message to be encoded.
        :return: The encoded integer.
        """
        return int(message.encode('utf-8').hex(), 16)
    
    def encrypt(self, plaintext: str) -> int:
        """
        Encrypt the plaintext message using the public key.
        :param plaintext: The plaintext message to be encrypted.
        :return: The ciphertext.
        """
        if self.n is None:
            raise ValueError("Public key not generated. Call generate_public_key first.")
        
        M = self._encode_message(plaintext)
        C = pow(M, self.e, self.n)
        return C
        # raise NotImplementedError("Encryption is not implemented.")
    
    def decrypt(self, ciphertext: int) -> str:
        """
        Decrypt the ciphertext using the private key.
        :param ciphertext: The ciphertext to be decrypted.
        :return: The decrypted plaintext message.
        """
        if self.d is None or self.n is None:
            raise ValueError("Private key not generated or public key missing.")

        M = pow(ciphertext, self.d, self.n)
        
        try:
            plaintext = bytes.fromhex(hex(M)[2:]).decode('utf-8')
        except Exception as e:
            raise ValueError("Failed to decode message: " + str(e))
        
        return plaintext
        # raise NotImplementedError("Decryption is not implemented.")
    
    def sign(self, message: str) -> int:
        """
        Sign the message using the private key.
        :param message: The message to be signed.
        :return: The signature.
        """
        if self.d is None or self.n is None:
            raise ValueError("Private key not generated or public key missing.")

        M = self._encode_message(message)
        signature = pow(M, self.d, self.n)
        return signature
        # raise NotImplementedError("Signing is not implemented.")
    
    def verify_signature(self, message: str, signature: int) -> bool:
        """
        Verify the signature of the message using the public key.
        :param message: The original message.
        :param signature: The signature to be verified.
        :return: True if the signature is valid, False otherwise.
        """
        if self.n is None:
            raise ValueError("Public key not generated.")

        M_expected = self._encode_message(message)
        M_from_signature = pow(signature, self.e, self.n)
        return M_expected == M_from_signature
        # raise NotImplementedError("Signature verification is not implemented.")

# example run for testing purposes 
if __name__ == "__main__":

    rsa = RSA(prime_bit_length=64, seed=42) 
    rsa.generate_primes()
    rsa.generate_public_key()
    rsa.generate_private_key()

    print(f"Primes: p = {rsa.p}, q = {rsa.q}")
    print(f"Public key (n, e): ({rsa.n}, {rsa.e})")
    print(f"Private key d: {rsa.d}\n")

    message = "hello"
    ciphertext = rsa.encrypt(message)
    decrypted = rsa.decrypt(ciphertext)

    print(f"Original Message: {message}")
    print(f"Ciphertext: {ciphertext}")
    print(f"Decrypted: {decrypted}")
    assert decrypted == message, "Decryption failed!"

    signature = rsa.sign(message)
    is_valid = rsa.verify_signature(message, signature)

    print(f"\nSignature: {signature}")
    print(f"Signature valid? {is_valid}")
    assert is_valid, "Signature verification failed!"
