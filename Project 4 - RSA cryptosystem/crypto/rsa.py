from typing import Union, Tuple
from crypto.primes import PrimeGenerator

class RSA:

    def __init__(self, prime_bit_length : int, seed: Union[int, None] = None):
        """
        Initialize the RSA object with a specified bit length and an optional seed for random number generation.
        :param bit_length: The bit length for the prime numbers to be generated.
        :param seed: An optional seed for the random number generator.
        """

        self.bit_length = prime_bit_length
        self.seed = seed
        self.prime_gen = PrimeGenerator(bits=prime_bit_length, seed=seed)
        self.p = None
        self.q = None
        self.n = None
        self.e = 0x10001     # can be hardcoded to be this value (65537)
        self.d = None

    def set_primes(self, p: int, q: int):
        
        """
        Set the prime numbers p and q, instead of using the ones generated by the PrimeGenerator.
        :param p: The first prime number.
        :param q: The second prime number.
        """
        self.p = p
        self.q = q

    def generate_primes(self):
        
        """
        Generate two distinct prime numbers p and q.
        """
        self.p = self.prime_gen.findPrime()
        self.q = self.prime_gen.findPrime()
        while self.p == self.q:
            self.q = self.prime_gen.findPrime()

    def generate_public_key(self) -> Tuple[int, int]:
        """
        Generate the public key (n, e).
        :return: A tuple containing n and e.
        """
        raise NotImplementedError("Public key generation is not implemented.")

    def generate_private_key(self) -> int:
        """
        Generate the private key d, and saves it interally.
        :return: The private key d.
        """
        raise NotImplementedError("Private key generation is not implemented.")
    
    def _encode_message(self, message: str) -> int:
        """
        Encode the message into an integer.
        :param message: The message to be encoded.
        :return: The encoded integer.
        """
        return int(message.encode('utf-8').hex(), 16)
    
    def encrypt(self, plaintext: str) -> int:
        """
        Encrypt the plaintext message using the public key.
        :param plaintext: The plaintext message to be encrypted.
        :return: The ciphertext.
        """
        
        raise NotImplementedError("Encryption is not implemented.")
    
    def decrypt(self, ciphertext: int) -> str:
        """
        Decrypt the ciphertext using the private key.
        :param ciphertext: The ciphertext to be decrypted.
        :return: The decrypted plaintext message.
        """
        
        raise NotImplementedError("Decryption is not implemented.")
    
    def sign(self, message: str) -> int:
        """
        Sign the message using the private key.
        :param message: The message to be signed.
        :return: The signature.
        """
        
        raise NotImplementedError("Signing is not implemented.")
    
    def verify_signature(self, message: str, signature: int) -> bool:
        """
        Verify the signature of the message using the public key.
        :param message: The original message.
        :param signature: The signature to be verified.
        :return: True if the signature is valid, False otherwise.
        """
        
        raise NotImplementedError("Signature verification is not implemented.")